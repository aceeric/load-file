using System;
using System.Collections.Generic;
using System.IO;
using static load_file.Globals;

namespace load_file
{
    /// <summary>
    /// Profiles and pre-processes a file
    /// </summary>
    class FileProcessor
    {
        /// <summary>
        /// Reads a user-specified number of lines from the top of the file, displays them to the console,
        /// and then exits/
        /// </summary>
        /// <param name="SplitCols">A Dictionary of column splitting specifiers. The key is a column name, and the
        /// value is the value within a field upon which to split. E.g. <"foo",":"> splits the foo column into foo,
        /// and foo_descr on the colon character</param>

        public static void Preview(Dictionary<string, string> SplitCols)
        {
            int InRows = 0;
            List<ProfileColumn> Cols = ProfileColumn.BuildColumnList(SplitCols);
            Dictionary<int, string> SplitOrdinals = SplitOrdinalsToDict(Cols);
            Log.InformationMessage("Previewing the file");
            using (FileReader Rdr = FileReader.NewFileReader(Cfg.File, Cfg.Prep))
            {
                List<string> InFields = null;
                while ((InFields = Rdr.ReadLine()) != null)
                {
                    if (SplitCols != null)
                    {
                        InFields = ProfileColumn.SplitFields(InFields, SplitOrdinals);
                    }
                    Log.InformationMessage(string.Join(",", InFields.ToArray()));
                    if (++InRows >= Cfg.Preview)
                    {
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Profiles and pre-processes a file. Pre-processing involves 1) removing headers and footers, 2) skipping lines,
        /// 3) un-quoting fields, and 4) splitting fields.
        /// </summary>
        /// <param name="PrepFileFqpn">The fully-qualified path name of the prepped file generated by the method. If the
        /// method does not perform prepping, then the output variable will be set to null</param>
        /// <param name="SplitCols">A Dictionary of column splitting specifiers. The key is a column name, and the
        /// value is the value within a field upon which to split. E.g. <"foo",":"> splits the foo column into foo,
        /// and foo_descr on the colon character</param>
        /// <returns>A List of ProfileColumn instances with data type info about the file.</returns>

        public static List<ProfileColumn> Process(out string PrepFileFqpn, Dictionary<string, string> SplitCols)
        {
            List<ProfileColumn> Cols = ProfileColumn.BuildColumnList(SplitCols);
            ProcessOneFile(Cols, out PrepFileFqpn, SplitCols != null);
            return Cols; 
        }

        /// <summary>
        /// Profiles and pre-processes a file. Pre-processing involves 1) removing headers and footers, 2) skipping lines,
        /// 3) un-quoting fields, and 4) splitting fields.
        /// </summary>
        /// <param name="Cols">A List of ProfileColumn instances to populate with data type information accumulated from the
        /// file data</param>
        /// <param name="PrepFileFqpn">The fully-qualified path name of the prepped file generated by the method. If the
        /// method does not perform prepping, then the output variable will be set to null</param>
        /// <param name="ShouldSplit">True if columns splitting should be performed. If true then the Cols arg will have
        /// already been split and so the method will split the input lines to align with the Cols list</param>
        /// <returns></returns>

        private static int ProcessOneFile(List<ProfileColumn> Cols, out string PrepFileFqpn, bool ShouldSplit)
        {
            int InRows = 0;
            int ErrRows = 0;
            {
                string Msg = "Processing file: {0}";
                if (Cfg.Profile && Cfg.Prep) Msg = "Profiling and Prepping file: {0}";
                else if (Cfg.Profile) Msg = "Profiling file: {0}";
                else if (Cfg.Prep) Msg = "Prepping file: {0}";
                Log.InformationMessage(Msg, Cfg.File);
            }
            bool DoFreqs = !string.IsNullOrEmpty(Cfg.FreqFile);
            int SkipLines = Math.Max(Cfg.SkipLines, Cfg.HeaderLine);
            DateTime Start = DateTime.Now;
            long BytesRead = 0;
            decimal FileSize = new FileInfo(Cfg.File).Length;

            Dictionary<int, string> SplitOrdinals = SplitOrdinalsToDict(Cols);

            using (FileReader Rdr = FileReader.NewFileReader(Cfg.File, Cfg.Prep))
            {
                List<string> InFields = null;
                StreamWriter PrepFileWriter = null;
                if ((PrepFileFqpn = Cfg.Prep ? MakePrepFileName(Cfg.File, Cfg.PrepDir) : null) != null)
                {
                    PrepFileWriter = new StreamWriter(PrepFileFqpn);
                }
                try
                {
                    while ((InFields = Rdr.ReadLine()) != null)
                    {
                        if (ShouldSplit)
                        {
                            InFields = ProfileColumn.SplitFields(InFields, SplitOrdinals);
                        }
                        ++InRows;
                        if (Cols != null && InFields.Count != Cols.Count)
                        {
                            // ERROR -- column count mismatch
                            ++ErrRows;
                            if (!string.IsNullOrEmpty(Cfg.ErrFile))
                            {
                                LogErrorRecord(SkipLines + InRows, InFields, Cfg.ErrFile);
                            }
                            if (Cfg.MaxErrors >= 0 && ErrRows > Cfg.MaxErrors) // Cfg.MaxErrors value of -1 means ignore all errors
                            {
                                throw new LoadException(string.Format("File {0} has a different number of columns than expected on row {1}. Expected: {2} Found: {3}", Cfg.File, SkipLines + InRows, Cols.Count, InFields.Count));
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if (PrepFileWriter != null)
                        {
                            // prepped file is always tab-delimited
                            PrepFileWriter.WriteLine(string.Join("\t", InFields.ToArray()));
                        }
                        if (Cfg.Profile)
                        {
                            for (int FldNum = 0; FldNum < InFields.Count; ++FldNum)
                            {
                                Cols[FldNum].Profile(InFields[FldNum], DoFreqs, Cfg.Typed);
                            }
                        }
                        if (InRows % 10000 == 0) // && Args.ShowProgress)
                        {
                            decimal PctComplete = Rdr.TotBytesRead / FileSize;
                            Log.InformationMessage("{0} rows ({1:P0})", InRows, PctComplete); // something to look at for large files
                        }
                    }
                    BytesRead = Rdr.TotBytesRead;
                }
                finally
                {
                    if (PrepFileWriter != null)
                    {
                        PrepFileWriter.Close();
                    }
                }
            }
            if (ErrRows != 0)
            {
                Log.InformationMessage("{0} error records were written to error file: {1}", ErrRows, Cfg.ErrFile);
            }
            Log.InformationMessage("Rows read: {0:n0} -- Error rows: {1:n0} -- Bytes read: {2:n0} -- Elapsed time (HH:MM:SS.Milli): {3}", InRows, ErrRows, BytesRead, DateTime.Now - Start);
            if (InRows == ErrRows)
            {
                // something went way wrong
                throw new LoadException(string.Format("No records in the input file matched the expected format."));
            }
            return InRows;
        }

        /// <summary>
        /// Reads the passed column list and builds a dictionary of column splitting information from it
        /// so that it can be efficiently accessed when splitting a line. This is purely a performance optimization.
        /// </summary>
        /// <param name="Cols">A list of ProfileColumn instances. If any instance has a SplitOrdinal value that is
        /// not -1, then that indicate that the columns is to be split. In that case the SplitOrdinal value is the
        /// ordinal position of the column in the file.</param>
        /// <returns>A Dictionary in which the key is the ordinal position in the input record of a field to be
        /// split, and the value is the string to split in. E.g. <3,"~"> means "split column 3 (zero-relative) on the 
        /// tilde character". May be empty - in which case no splitting is required. Guaranteed non-null.</returns>

        private static Dictionary<int, string> SplitOrdinalsToDict(List<ProfileColumn> Cols)
        {
            Dictionary<int, string> SplitOrdinals = new Dictionary<int, string>();
            foreach (ProfileColumn Col in Cols)
            {
                if (Col.SplitOrdinal != -1)
                {
                    SplitOrdinals.Add(Col.SplitOrdinal, Col.SplitStr);
                }
            }
            return SplitOrdinals;
        }

        /// <summary>
        /// Write a record from the input file to an error file.
        /// </summary>
        /// <param name="RowNum">The 1-relative row number of the passed row within the input file</param>
        /// <param name="InFields">The row, represented as a List of strings, in which each string is a field</param>
        /// <param name="ErrFile">The path name of the error file</param>

        private static void LogErrorRecord(int RowNum, List<string> InFields, string ErrFile)
        {
            using (StreamWriter sw = new StreamWriter(ErrFile, true)) // true means append
            {
                sw.WriteLine(RowNum.ToString() + ":: " + string.Join("\t", InFields.ToArray()));
            }
        }

        /// <summary>
        /// Generates a unique name in the passed  directory from the passed file name. E.g. if:
        /// SrcFile="c:\foo\bar.txt" and PrepDir="c:\tmp" then returns like: "c:\tmp\bar.20171231-125959.999.prepped"
        /// </summary>
        /// <param name="SrcFile">The path specifier of the file name being read</param>
        /// <param name="PrepDir">The directory name to write the prep file into (could be the same directory
        /// as the directory holding the source file). Can also be null or empty indicating that the prep file should
        /// be generated into the same directory as the source file.</param>
        /// <returns>the source file name with a datetime and "prepped" appended.</returns>
        private static string MakePrepFileName(string SrcFile, string PrepDir)
        {
            PrepDir = string.IsNullOrEmpty(PrepDir) ? Path.GetDirectoryName(SrcFile) : Path.GetFullPath(PrepDir);
            return Path.Combine(PrepDir, Path.GetFileName(SrcFile)) + DTString();
        }

        /// <summary>
        /// Returns a file suffix that can be appended to a filename to make a filename
        /// reasonably unique. E.g., ".20160107-133501.612.prepped". You could break it I guess by running it at exactly the
        /// same millisecond for exactly the same file into exactly the same directory - but this seems unlikely...
        /// </summary>
        /// <returns>A string in the format ".YYYYMMDD-HHMMSS.milliseconds.prepped" </returns>

        private static string DTString()
        {
            return DateTime.Now.ToString(".yyyyMMdd-HHmmss.fff.\"prepped\"");
        }

        /// <summary>
        /// Makes a reasonable effort to determine whether the passed file is a text file.
        /// </summary>
        /// <param name="filespec">The path to the file</param>
        /// <returns>True if the file is probably a text file (nothing is 100% certain, I guess)</returns>

        public static bool IsTextFile(string filespec)
        {
            // StreamReader handles BOM for us
            using (StreamReader Reader = new StreamReader(filespec))
            {
                char[] buffer = new char[100];
                int Offset = 0, SizeToRead = 100, BlocksToRead = 0, BytesRead = 0, BlocksRead = 0;
                while ((BytesRead = Reader.Read(buffer, Offset, SizeToRead)) != 0)
                {
                    for (int i = 0; i < BytesRead; ++i)
                    {
                        if (char.IsControl(buffer[i]) && !buffer[i].In('\t', '\r', '\n'))
                        {
                            return false;
                        }
                    }
                    if (++BlocksRead >= BlocksToRead)
                    {
                        return true;
                    }
                }
                return true;
            }
        }
    }
}
